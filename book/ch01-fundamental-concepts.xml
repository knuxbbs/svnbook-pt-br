<chapter id="svn.basic">
  <title>Conceitos Fundamentais</title>

  <para>Este capítulo é uma breve e casual introdução ao Subversion.
    Se você é novo em controle de versão, este capítulo é
    definitivamente para você. Nós começaremos com uma discussão
    sobre os conceitos gerais de controle de versão, avançaremos
    para as idéias específicas por trás do Subversion, e mostraremos
    alguns exemplos simples do Subversion em uso.</para>

  <para>Embora os exemplos neste capítulo mostrem pessoas compartilhando
    coleções de código fonte de programas, tenha em mente que o Subversion
    pode gerenciar qualquer tipo de coleção de arquivos - ele não está limitado
    a ajudar programadores.</para>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.basic.repository">
    <title>O Repositório</title>

    <para>
      O Subversion é um sistema centralizado de compartilhamento de
      informação. Em seu núcleo está um repositório, que é uma central
      de armazenamento de dados. O repositório armazena informação em
      forma de uma
      <firstterm>árvore de arquivos</firstterm>
      - uma hierarquia típica de arquivos e diretórios. Qualquer número
      de
      <firstterm>clientes</firstterm>
      se conecta ao repositório, e
      então lê ou escreve nestes arquivos. Ao gravar dados, um cliente
      torna a informação disponível para outros; ao ler os dados, o
      cliente recebe informação de outros.
      <xref linkend="svn.basic.repository.dia-1" />
      ilustra isso.
    </para>

    <figure id="svn.basic.repository.dia-1">
      <title>Um típico sistema cliente/servidor</title>
      <graphic fileref="images/ch02dia1.png" />
    </figure>

    <para>
      Então, por que razão isto é interessante? Até ao momento,
      isto soa como a definição de um típico servidor de arquivos.
      E, na verdade, o repositório
      <emphasis>é</emphasis>
      uma espécie
      de servidor de arquivos, mas não de um tipo comum. O que torna o
      repositório do Subversion especial é que
      <emphasis>ele se lembra
      de cada alteração</emphasis>
      já ocorrida nele: de cada mudança em
      cada arquivo, e até mesmo alterações na árvore de diretórios em
      si, como a adição, eliminação, e reorganização de arquivos e
      diretórios.
    </para>

    <para>
      Quando um cliente lê dados de um repositório, ele normalmente
      vê apenas a última versão da árvore de arquivos. Mas o cliente
      também tem a habilidade de ver os estados
      <emphasis>anteriores
      </emphasis>
      do sistema de arquivos. Por exemplo, um cliente pode
      perguntar questões de histórico como,
      <quote>O que este
      diretório continha na última quarta-feira?</quote>
      ou
      <quote>Quem
      foi a última pessoa que alterou este arquivo, e que alterações ela
      fez?</quote>
      Estes são os tipos de questões que estão no coração
      de qualquer
      <firstterm>sistema de controle de versão</firstterm>
      :
      sistemas que são projetados para monitorar alterações nos dados ao
      longo do tempo.
    </para>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.basic.vsn-models">
    <title>Modelos de Versionamento</title>

    <para>A missão principal de um sistema de controle de versão é permitir
      a edição colaborativa e o compartilhamento de dados. Mas diferentes
      sistemas usam diferentes estratégias para atingir esse objetivo. É
      importante compreender essas diferentes estratégias por várias razões.
      Primeiro, irá ajudá-lo a comparar os sistemas de controle de versão
      existentes, no caso de você encontrar outros sistemas similares ao
      Subversion. Além disso, irá ajudá-lo ainda a tornar o uso do Subversion
      mais eficaz, visto que o Subversion por si só permite trabalhar de
      diferentes formas.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.vsn-models.problem-sharing">
      <title>O Problema do Compartilhamento de Arquivos</title>

      <para>Todos os sistemas de controle de versão têm de resolver
        o mesmo problema fundamental: como o sistema irá permitir que
        os usuários compartilhem informação, e como ele irá prevenir
        que eles acidentalmente tropecem uns nos pés dos outros? É muito
        fácil para os usuários acidentalmente sobrescrever as mudanças
        feitas pelos outros no repositório.</para>

      <para>
        Considere o cenário mostrado em
        <xref linkend="svn.basic.vsn-models.problem-sharing.dia-1" />
        .
        Vamos supor que nós temos dois colegas de trabalho, Harry e
        Sally. Cada um deles decide editar o mesmo arquivo no repositório
        ao mesmo tempo. Se Harry salvar suas alterações no repositório
        primeiro, então é possível que (poucos momentos depois) Sally
        possa acidentalmente sobrescrevê-lo com a sua própria nova versão
        do arquivo. Embora a versão de Harry não seja perdida para sempre
        (porque o sistema se lembra de cada mudança), todas as mudanças
        feitas por Harry
        <emphasis>não</emphasis>
        vão estar presentes na
        versão mais recente do arquivo de Sally, porque ela nunca viu as
        mudanças de Harry's para começar. O trabalho de Harry efetivamente
        se perdeu - ou pelo menos desapareceu da última versão do arquivo -
        e provavelmente por acidente. Trata-se definitivamente de uma
        situação que queremos evitar!
      </para>

      <figure id="svn.basic.vsn-models.problem-sharing.dia-1">
        <title>O problema para evitar</title>
        <graphic fileref="images/ch02dia2.png" />
      </figure>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.vsn-models.lock-unlock">
      <title>A Solução Lock-Modify-Unlock</title>

      <para>
        Muitos sistemas de controle de versão usam o modelo
        <firstterm>lock-modify-unlock</firstterm>
        (travar-modificar-destravar)
        para resolver o problema de vários autores destruírem o trabalho uns
        dos outros. Neste modelo, o repositório permite que apenas uma
        pessoa de cada vez altere o arquivo. Essa política de exclusividade
        é gerenciada usando locks (travas). Harry precisa
        <quote>travar
        </quote>
        (lock) um arquivo antes que possa fazer alterações nele.
        Se Harry tiver travado o arquivo, então Sally não poderá travá-lo
        também, e portanto, não poderá fazer nenhuma alteração nele. Tudo que
        ela pode fazer é ler o arquivo, e esperar que Harry termine suas
        alterações e destrave (unlock) o arquivo. Depois que Harry destravar
        o arquivo, Sally poderá ter a sua chance de travar e editar o arquivo.
        A figura
        <xref linkend="svn.basic.vsn-models.lock-unlock.dia-1" />
        demonstra essa solução simples.
      </para>

      <figure id="svn.basic.vsn-models.lock-unlock.dia-1">
        <title>A solução lock-modify-unlock</title>
        <graphic fileref="images/ch02dia3.png" />
      </figure>

      <para>O problema com o modelo lock-modify-unlock é que ele é um pouco
        restritivo, muitas vezes se torna um obstáculo para os usuários:
      </para>

      <itemizedlist>
        <listitem>
          <para>
            <emphasis>Locks podem causar problemas
            administrativos.</emphasis>
            Algumas vezes Harry irá travar o arquivo e se esquecer disso.
            Entretanto, devido a Sally ainda estar esperando para editar
            o arquivo, suas mãos estão atadas. E Harry então sai de férias.
            Agora Sally tem que pedir a um administrador para destravar
            o arquivo que Harry travou. Essa situação acaba causando uma
            série de atrasos desnecessários e perda de tempo.
          </para>
        </listitem>

        <listitem>
          <para>
            <emphasis>Locking pode causar serialização
            desnecessária.</emphasis>
            E se Harry está editando o começo de um arquivo de texto,
            e Sally simplesmente quer editar o final do mesmo arquivo?
            Essas mudanças não vão se sobrepor afinal. Eles podem
            facilmente editar o arquivo simultaneamente, sem grandes
            danos, assumindo que as alterações serão apropriadamente
            fundidas depois. Não há necessidade de se trabalhar em
            turnos nessa situação.
          </para>
        </listitem>

        <listitem>
          <para>
            <emphasis>Locking pode criar falsa sensação
            de segurança.</emphasis>
            Suponha que Harry trave e edite o arquivo A, enquanto Sally
            simultaneamente trava e edita o arquivo B. Mas e se A e B dependem
            um do outro, e se as mudanças feitas em cada são semanticamente
            incompatíveis? Subitamente A e B não funcionam juntos mais.
            O sistema de locking não foi suficientemente poderoso para
            prevenir o problema - ainda que de certa forma tenha proporcionado
            uma falsa sensação de segurança. É fácil para Harry e Sally imaginar
            que travando os arquivos, cada um está começando uma tarefa isolada
            segura, e assim não se preocupar em discutir as incompatibilidades
            que virão com suas mudanças. Locking freqüentemente se torna um
            substituto para a comunicação real.
          </para>
        </listitem>
      </itemizedlist>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.vsn-models.copy-merge">
      <title>A Solução Copy-Modify-Merge</title>

      <para>
        O Subversion, CVS, e muitos outros sistemas de controle de versão
        usam um modelo de
        <firstterm>copy-modify-merge</firstterm>
        (copiar-modificar-fundir) como uma alternativa ao locking. Nesse modelo,
        cada usuário se conecta ao repositório do projeto e cria uma
        <firstterm>
        cópia de trabalho</firstterm>
        pessoal (personal working copy, ou cópia
        local) - um espelho local dos arquivos e diretórios do repositório. Os
        usuários então trabalham simultaneamente e independentemente, modificando
        suas cópias privadas. Finalmente, as cópias privadas são fundidas (merged)
        numa nova versão final. O sistema de controle de versão freqüentemente
        ajuda com a fusão, mas, no final, a intervenção humana é a única capaz
        de garantir que as mudanças foram realizadas de forma correta.
      </para>

      <para>
        Aqui vai um exemplo. Digamos que Harry e Sally criaram cada um a sua
        cópia de trabalho de um mesmo projeto, copiadas do repositório. Eles
        trabalharam simultaneamente fazendo alterações no arquivo A nas
        suas próprias cópias. Sally salva suas alterações no repositório primeiro.
        Quando Harry tentar salvar suas alterações mais tarde, o repositório vai
        informá-lo que seu arquivo A está
        <firstterm>desatualizado</firstterm>
        (out-of-date). Em outras palavras, o arquivo A do repositório foi de
        alguma forma alterado desde a última vez que ele foi copiado. Então Harry
        pede a seu programa cliente para ajudá-lo a
        <firstterm>fundir</firstterm>
        (merge) todas as alterações do repositório na sua cópia de trabalho do arquivo
        A. Provavelmente, as mudanças de Sally não se sobrepõem com as suas próprias;
        então, uma vez que ele tiver ambos os conjuntos de alterações integrados,
        ele salva sua cópia de trabalho de volta no repositório. As figuras
        <xref linkend="svn.basic.vsn-models.copy-merge.dia-1" />
        e
        <xref linkend="svn.basic.vsn-models.copy-merge.dia-2" />
        mostram este
        processo.
      </para>

      <figure id="svn.basic.vsn-models.copy-merge.dia-1">
        <title>A solução copy-modify-merge</title>
        <graphic fileref="images/ch02dia4.png" />
      </figure>

      <figure id="svn.basic.vsn-models.copy-merge.dia-2">
        <title>A solução copy-modify-merge (continuando)</title>
        <graphic fileref="images/ch02dia5.png" />
      </figure>

      <para>
        Mas e se as alterações de Sally
        <emphasis>sobrescreverem</emphasis>
        as de Harry? E então? Essa situação é chamada de
        <firstterm>conflito
        </firstterm>
        , e normalmente não é um problema. Quando Harry pedir a seu
        cliente para fundir as últimas alterações do repositório em sua cópia de
        trabalho local, sua cópia do arquivo A estará de alguma forma sinalizada
        como estando numa situação de conflito: ele será capaz de ver ambos os
        conjuntos de alterações conflitantes e manualmente escolher entre elas.
        Note que o software não tem como resolver os conflitos automaticamente;
        apenas pessoas são capazes de compreender e fazer as escolhas
        inteligentes. Uma vez que Harry tenha resolvido manualmente as
        alterações conflitantes - talvez depois de uma conversa com Sally -
        ele poderá tranqüilamente salvar o arquivo fundido no
        repositório.
      </para>

      <para>O modelo copy-modify-merge pode soar um pouco caótico, mas,
        na prática, ele funciona de forma bastante suave. Os usuários
        podem trabalhar em paralelo, nunca esperando uns pelos outros.
        Quando eles trabalham nos mesmos arquivos, verifica-se que a
        maioria de suas alterações simultâneas não se sobrepõe afinal;
        conflitos não são muito freqüentes. E a quantidade de tempo que
        eles levam para resolver os conflitos é geralmente muito menor
        que o tempo perdido no sistema de locking.</para>

      <para>No fim, tudo se reduz a um fator crítico: a comunicação entre os
        usuários. Quando os usuários se comunicam mal, tanto conflitos sintáticos
        como semânticos aumentam. Nenhum sistema pode forçar os usuários a se
        comunicarem perfeitamente, e nenhum sistema pode detectar conflitos
        semânticos. Portanto, não há como confiar nessa falsa sensação de segurança
        de que o sistema de locking vai prevenir conflitos; na prática, o lock parece
        inibir a produtividade mais do que qualquer outra coisa.</para>

      <sidebar id="svn.basic.vsn-models.copy-merge.sb-1">
        <title>Quando Lock é Necessário</title>

        <para>Enquanto o modelo lock-modify-unlock é geralmente 
          considerado prejudicial à colaboração, ainda há momentos
          em que ele é apropriado.</para>

        <para>O modelo copy-modify-merge é baseado no pressuposto
          de que os arquivos são contextualmente fundíveis: isto
          é, que os arquivos no repositório sejam majoritariamente
          texto plano (como código-fonte). Mas para arquivos com
          formatos binários, como os de imagens ou som, freqüentemente
          é impossível fundir as mudanças conflitantes. Nessas
          situações, é realmente necessário que o arquivo seja
          alterado por um usuário de cada vez. Sem um acesso
          serializado, alguém acabará perdendo tempo em
          mudanças que no final serão descartadas.</para>

        <para>
          Enquanto o Subversion é primariamente um sistema copy-modify-merge,
          ele ainda reconhece a necessidade ocasional de locking em algum arquivo e
          assim fornece mecanismos para isso. Este recurso será discutido mais
          tarde neste livro, em
          <xref linkend="svn.advanced.locking" />
          .
        </para>

      </sidebar>


    </sect2>

  </sect1>

  <!-- How svn implements the philosophy -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.basic.in-action">
    <title>Subversion em Ação</title>

    <para>Chegou a hora de passar do abstrato para o concreto.
    Nesta seção, nós mostraremos exemplos reais de utilização
    do Subversion</para>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.reposurls">
      <title>URLs do Repositório Subversion</title>

      <para>Ao longo de todo este livro, o Subversion utiliza URLs para
        identificar arquivos e diretórios versionados nos repositórios.
        Na maior parte, essas URLs usam a sintaxe padrão, permitindo
        nomes de servidor e números de porta serem especificados como
        parte da URL:</para>

      <screen>
$ svn checkout http://svn.example.com:9834/repos
...
</screen>

      <para>
        Mas existem algumas nuances no manuseio de URLs pelo
        Subversion que são notáveis. Por exemplo, URLs contendo
        o método de acesso
        <literal>file://</literal>
        (usado para
        repositórios locais) precisam, de acordo com a convenção,
        ter como nome do servidor
        <literal>localhost</literal>
        ou
        nenhum nome de servidor:
      </para>

      <screen>
$ svn checkout file:///path/to/repos
...
$ svn checkout file://localhost/path/to/repos
...
</screen>

      <para>
        Além disso, usuários do esquema
        <literal>file://</literal>
        em plataformas Windows precisarão utilizar um padrão de
        sintaxe
        <quote>não-oficial</quote>
        para acessar
        repositórios que estão na mesma máquina, mas em um
        drive diferente do atual drive de trabalho. Qualquer
        uma das seguintes sintaxes de URLs funcionarão,
        sendo
        <literal>X</literal>
        o drive onde o repositório
        reside:
      </para>

      <screen>
C:\&gt; svn checkout file:///X:/path/to/repos
...
C:\&gt; svn checkout "file:///X|/path/to/repos"
...
</screen>

      <para>Na segunda sintaxe, você precisa colocar a URL entre aspas
        de modo que o caractere de barra vertical não seja interpretado
        como um pipe. Além disso, note que a URL utiliza barras normais,
        enquanto no Windows os caminhos (não URLs) utilizam barra invertida.</para>

      <note>
        <para>
          URLs
          <literal>file://</literal>
          do Subversion não podem
          ser utilizadas em um browser comum da mesma forma que URLs
          <literal>file://</literal>
          típicas podem. Quando você tenta
          ver uma URL
          <literal>file://</literal>
          num web browser comum,
          ele lê e mostra o conteúdo do local examinando o sistema de
          arquivos diretamente. Entretanto, os recursos do Subversion
          existem em um sistema de arquivos virtual (veja
          <xref linkend="svn.developer.layerlib.repos" />
          ), e o seu
          browser não vai saber como interagir com este sistema de
          arquivos.
        </para>
      </note>

      <para>Por último, convém notar que o cliente Subversion vai
        automaticamente codificar as URLs conforme necessário, de
        forma semelhante a um browser. Por exemplo, se a URL contiver
        espaços ou algum caractere não-ASCII:</para>

      <screen>
$ svn checkout "http://host/path with space/project/españa"
</screen>

      <para>...então o Subversion irá aplicar "escape" aos caracteres inseguros
        e se comportar como se você tivesse digitado:</para>

      <screen>
$ svn checkout http://host/path%20with%20space/project/espa%C3%B1a
</screen>

      <para>
        Se a URL contiver espaços, certifique-se de colocá-la entre aspas,
        de forma que o seu shell trate-a inteiramente como um único argumento
        do programa
        <command>svn</command>
        .
      </para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.in-action.wc">
      <title>Cópias de Trabalho, ou Cópias Locais</title>

      <para>Você já leu sobre as cópias de trabalho; agora
        vamos demonstrar como o cliente do Subversion as
        cria e usa.</para>

      <para>Uma cópia de trabalho do Subversion é uma árvore de diretórios
        comum no seu sistema de arquivos local, contendo uma coleção de arquivos.
        Você pode editar esses arquivos conforme desejar, e se eles são arquivos
        de código fonte, você pode compilar o seu programa a partir deles da
        maneira usual. Sua cópia de local é sua área de trabalho privada:
        O Subversion jamais incorporará as mudanças de terceiros ou tornará as suas
        próprias alterações disponíveis para os outros, até que você explicitamente
        o diga para fazer isso. Você pode ter múltiplas cópias de trabalho do
        o mesmo projeto.</para>

      <para>
        Após você ter feito algumas alterações nos arquivos de sua
        cópia de trabalho e verificado que elas funcionam corretamente,
        o Subversion lhe disponibiliza comandos para
        <quote>publicar</quote>
        (commit) suas alterações para as outras pessoas que estão trabalhando
        com você no mesmo projeto (gravando no repositório). Se outras pessoas
        publicarem alterações, o Subversion disponibiliza comandos para
        fundir (merge) essas alterações em sua cópia de trabalho (lendo do
        repositório).
      </para>

      <para>
        Uma cópia de trabalho também contém alguns arquivos extras,
        criados e mantidos pelo Subversion, para ajudá-lo a executar
        esse comandos. Em particular, cada diretório em sua cópia local
        contém um subdiretório chamado
        <filename>.svn</filename>
        , também
        conhecido como o
        <firstterm>diretório administrativo</firstterm>
        da cópia de local. Os arquivos em cada diretório administrativo
        ajudam o Subversion a reconhecer quais arquivos possuem alterações
        não-publicadas, e quais estão desatualizados em relação ao trabalho
        dos outros.
      </para>

      <para>Um típico repositório Subversion freqüentemente detém os arquivos
        (ou código fonte) para vários projetos, geralmente, cada projeto é um
        subdiretório na árvore de arquivos do repositório. Desse modo, uma
        cópia de trabalho de um normalmente corresponderá a uma sub-árvore
        particular do repositório.</para>

      <para>
        Por exemplo, suponha que você tenha um repositório
        que contenha dois projetos de software,
        <literal>paint
        </literal>
        e
        <literal>calc</literal>
        . Cada projeto reside
        em seu próprio subdiretório, como é mostrado em
        <xref linkend="svn.basic.in-action.wc.dia-1" />
        .
      </para>

      <figure id="svn.basic.in-action.wc.dia-1">
        <title>O Sistema de Arquivos do Repositório</title>
        <graphic fileref="images/ch02dia6.png" />
      </figure>

      <para>
        Para obter uma cópia local, você deve fazer
        <firstterm>check out</firstterm>
        de alguma sub-árvore do repositório.
        (O termo
        <quote>check out</quote>
        pode soar como algo que tem a ver com
        locking ou com reserva de recursos, o que não é verdade; ele simplesmente
        cria uma cópia privada do projeto para você.) Por exemplo, se você fizer
        check out de
        <filename>/calc</filename>
        , você receberá uma cópia de
        trabalho como esta:
      </para>

      <screen>
$ svn checkout http://svn.example.com/repos/calc
A    calc/Makefile
A    calc/integer.c
A    calc/button.c
Checked out revision 56.

$ ls -A calc
Makefile  integer.c  button.c  .svn/
</screen>

      <para>
        A lista de letras A na margem esquerda indica que o
        Subversion está adicionando um certo número de itens à
        sua cópia de trabalho. Você tem agora uma cópia pessoal
        do diretório
        <filename>/calc</filename>
        do repositório,
        com uma entrada adicional -
        <filename>.svn</filename>
        -
        a qual detém as informações extras que o Subversion
        precisa, conforme mencionado anteriormente.
      </para>

      <para>
        Suponha que você faça alterações no arquivo
        <filename>button.c</filename>
        . Visto que o diretório
        <filename>.svn</filename>
        se lembra da data de modificação e conteúdo
        do arquivo original, o Subversion tem como saber que você modificou
        o arquivo. Entretanto o Subversion não torna as suas alterações públicas
        até você explicitamente lhe dizer para fazer isto. O ato de publicar
        as suas alterações é conhecido como
        <firstterm>committing</firstterm>
        (ou
        <firstterm>checking in</firstterm>
        ) no repositório.
      </para>

      <para>
        Para publicar as suas alterações para os outros, você deve usar o
        comando
        <command>commit</command>
        do Subversion.
      </para>

      <screen>
$ svn commit button.c -m "Fixed a typo in button.c."
Sending        button.c
Transmitting file data .
Committed revision 57.
</screen>

      <para>
        Agora as suas alterações no arquivo
        <filename>button.c
      	</filename>
        foram
        <quote>submetidas</quote>
        no repositório, com uma nota
      	descrevendo as suas alterações (especificamente você corrigiu
      	um erro de digitação). Se outros usuários fizerem check out
      	de
        <filename>/calc</filename>
        , eles verão suas alterações
      	na última versão do arquivo.
      </para>

      <para>
        Suponha que você tenha um colaborador, Sally, que tenha
      	feito check out de
        <filename>/calc</filename>
        ao mesmo tempo
      	que você. Quando você publicar suas alterações em
        <filename>
      	button.c</filename>
        , a cópia de trabalho de Sally será deixada
      	intacta; o Subversion somente modifica as cópias locais quando
      	o usuário requisita.
      </para>

      <para>
        Para atualizar o seu projeto, Sally pede ao Subversion
      	para realizar um
        <firstterm>update</firstterm>
        na cópia de
      	trabalho dela, usando o comando
        <command>update</command>
        do Subversion. Isto irá incorporar as suas alterações na
      	cópia local dela, bem como as alterações de todos que tenham
      	feito um commit desde que ela fez check out.
      </para>

      <screen>
$ pwd
/home/sally/calc

$ ls -A 
.svn/ Makefile integer.c button.c

$ svn update
U    button.c
Updated to revision 57.
</screen>

      <para>
        A saída do comando
        <command>svn update</command>
        indica que o Subversion atualizou o conteúdo de
        <filename>button.c</filename>
        . Note que Sally não precisou
      	especificar quais arquivos seriam atualizados; o Subversion
      	usou as informações no diretório
        <filename>.svn</filename>
        ,
        e mais algumas no repositório, para decidir quais arquivos
        precisariam ser atualizados.
      </para>

      <sidebar id="svn.basic.in-action.wc.sb-1">
        <title>URLs do Repositório</title>

        <para>
          Os repositórios do Subversion podem ser acessados
          através de diversos métodos - em um disco local, através
          de vários protocolos de rede, dependendo de como o
          administrador configurou as coisas para você. Qualquer
          local no repositório, entretanto, é sempre uma URL. A
          Tabela
          <xref linkend="svn.basic.in-action.wc.tbl-1" />
          descreve como diferentes esquemas de URLs mapeiam para
          os métodos de acesso disponíveis.
        </para>

        <table id="svn.basic.in-action.wc.tbl-1">
          <title>URLs de Acesso ao Repositório</title>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>Esquema</entry>
                <entry>Método de Acesso</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <literal>file:///</literal>
                </entry>
                <entry>acesso direto ao repositório (em um disco local).</entry>
              </row>
              <row>
                <entry>
                  <literal>http://</literal>
                </entry>
                <entry>acesso via protocolo WebDAV em um servidor Apache especialmente
                  configurado.</entry>
              </row>
              <row>
                <entry>
                  <literal>https://</literal>
                </entry>
                <entry>
                  mesmo que
                  <literal>http://</literal>
                  ,
                  mas com encriptação SSL.
                </entry>
              </row>
              <row>
                <entry>
                  <literal>svn://</literal>
                </entry>
                <entry>
                  acesso via protocolo próprio em um servidor
                  <literal>svnserve</literal>
                  .
                </entry>
              </row>
              <row>
                <entry>
                  <literal>svn+ssh://</literal>
                </entry>
                <entry>
                  mesmo que
                  <literal>svn://</literal>
                  ,
                  mas através de um túnel SSH.
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>
          Para obter mais informações sobre como o Subversion
          analisa as URLs, veja
          <xref linkend="svn.advanced.reposurls" />
          .
          Para obter mais informações sobre os diferentes tipos de servidores
          de rede disponíveis para Subversion, veja
          <xref linkend="svn.serverconfig" />
          .
        </para>

      </sidebar>

    </sect2>


    <!-- =============================================================== -->
    <sect2 id="svn.basic.in-action.revs">
      <title>Revisões</title>

      <para>
        Uma operação
        <command>svn commit</command>
        publica as alterações
        feitas em qualquer número de arquivos o diretórios como uma única
        transação atômica. Em sua cópia de trabalho, você pode alterar o conteúdo
        de arquivos; criar, deletar, renomear e copiar arquivos e diretórios;
        e então submeter um conjunto completo de alterações em uma transação
        atômica.
      </para>

      <para>
        Por
        <quote>transação atômica</quote>
        , nos entendemos simplesmente
	isto: Ou são efetivadas todas as alterações no repositório, ou nenhuma
	delas. O Subversion tenta manter esta atomicidade em face de quebras ou travamentos
	do programa ou do sistema, problemas de rede ou outras ações de
	usuários.
      </para>

      <para>
        Cada vez que o repositório aceita um commit, isto cria
	um novo estado na árvore de arquivos, chamado
        <firstterm>revisão</firstterm>
        . Cada revisão é assinalada
	com um único número natural, incrementado de um em relação
	à revisão anterior. A revisão inicial de um repositório recém
	criado é numerada com zero, e consiste em nada além de um
	diretório raiz vazio.
      </para>

      <para>
        A figura
        <xref linkend="svn.basic.in-action.revs.dia-1" />
        ilustra uma forma simples
        para visualizar o repositório. Imagine um array de números de revisões, iniciando
        em zero, alongando-se da esquerda para a direita. Cada número de revisão tem
        uma árvore de arquivos pendurada abaixo dela, e cada árvore é um
        <quote>snapshot</quote>
        da forma como o repositório podia ser visto após
        um commit.
      </para>

      <figure id="svn.basic.in-action.revs.dia-1">
        <title>O Repositório</title>
        <graphic fileref="images/ch02dia7.png" />
      </figure>

      <sidebar>
        <title>Números de Revisão Globais</title>

        <para>
          Ao contrários de outros sistemas de controle de versão,
          os números de revisão do Subversion se aplicam à
          <emphasis>árvore inteira</emphasis>
          , não a arquivos individuais.
          Cada número de revisão refere-se a uma árvore inteira, um estado
          particular do repositório após determinadas alterações serem submetidas.
          Uma outra forma de pensar a respeito é imaginar que a revisão
          N representa o estado do sistema de arquivos do repositório após o
          N-ésimo commit. Quando os usuários do Subversion falam sobre a
          <quote>
            revisão número 5 do arquivo
            <filename>foo.c</filename>
          </quote>
          ,
          eles realmente entendem o
          <quote>
            <filename>foo.c</filename>
            que aparece
          na revisão 5.
          </quote>
          Note que em geral, revisões N e M de um arquivo
          podem
          <emphasis>não</emphasis>
          ser necessariamente diferentes! Muitos
          outros sistemas de controle de versão usam número de revisão por arquivo,
          então este conceito pode parecer não usual à primeira vista. (Usuários
          do CVS podem querer ver
          <xref linkend="svn.forcvs" />
          para mais
          detalhes.)
        </para>
      </sidebar>

      <para>É importante notar que nem sempre as cópias de trabalho
        correspondem a uma única revisão do repositório; elas podem
        conter arquivos de várias revisões diferentes. Por exemplo,
        suponha que você faça checkout de uma cópia de trabalho cuja
        revisão mais recente seja 4:</para>

      <screen>
calc/Makefile:4
     integer.c:4
     button.c:4
</screen>

      <para>
        Neste momento, este diretório de trabalho corresponde exatamente
        à revisão número 4 no repositório. Contudo, suponha que você faça uma
        alteração no arquivo
        <filename>button.c</filename>
        , e publique essa
        alteração. Assumindo que nenhum outro commit tenha sido feito, o seu
        commit irá criar a revisão 5 no repositório, e sua cópia de trabalho
        agora irá parecer com isto:
      </para>

      <screen>
calc/Makefile:4
     integer.c:4
     button.c:5
</screen>

      <para>
        Suponha que neste ponto, Sally publique uma alteração no arquivo
        <filename>integer.c</filename>
        , criando a revisão 6. Se você usar o
        comando
        <command>svn update</command>
        para atualizar a sua cópia de
        trabalho, então ela irá parecer com isto:
      </para>

      <screen>
calc/Makefile:6
     integer.c:6
     button.c:6
</screen>

      <para>
        A alteração de Sally no arquivo
        <filename>integer.c</filename>
        irá aparecer em sua cópia de trabalho, e a sua alteração no
        arquivo
        <filename>button.c</filename>
        ainda estará presente. Neste
        exemplo, o texto do arquivo
        <filename>Makefile</filename>
        é idêntico
        nas revisões 4, 5, e 6, mas o Subversion irá marcar a sua cópia do
        arquivo
        <filename>Makefile</filename>
        com a revisão 6 para indicar que
        a mesma é a corrente. Então, depois de você fazer uma atualização
        completa na sua cópia de trabalho, ela geralmente corresponderá
        exatamente a uma revisão do repositório.
      </para>

    </sect2>


    <!-- =============================================================== -->
    <sect2 id="svn.basic.in-action.track-repos">
      <title>Como as Cópias de Trabalho Acompanham o Repositório</title>

      <para>
        Para cada arquivo em um diretório de trabalho, o Subversion
        registra duas peças de informações essenciais na área administrativa
        <filename>.svn/</filename>
        :
      </para>


      <itemizedlist>
        <listitem>
          <para>
            em qual revisão o seu arquivo local é baseado
            (isto é chamado de
            <firstterm>revisão local</firstterm>
            do arquivo), e
          </para>
        </listitem>

        <listitem>
          <para>a data e a hora da última vez que a cópia local foi atualizada
            a partir do repositório.</para>
        </listitem>
      </itemizedlist>

      <para>Dadas estas informações, conversando com o repositório,
        o Subversion pode dizer em qual dos seguintes quatro estados
        um arquivo local está:</para>

      <variablelist>
        <varlistentry>
          <term>Não-Modificado, e corrente</term>

          <listitem>
            <para>
              O arquivo não foi modificado no diretório local,
              e nenhuma alteração foi publicada no repositório
              desde a revisão corrente. O comando
              <command>
              svn commit</command>
              no arquivo não fará nada,
              e um comando
              <command>svn update
              </command>
              também não..
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Localmente alterado, e corrente</term>

          <listitem>
            <para>
              O arquivo foi alterado no diretório local, mas
              nenhuma alteração foi publicada no repositório desde
              o último update. existem alterações locais que ainda
              não foram publicadas no repositório, assim o comando
              <command>svn commit</command>
              no arquivo resultará na
              publicação dessas alterações, e um comando
              <command>svn
              update</command>
              não fará nada.
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Não-Modificado, e desatualizado</term>

          <listitem>
            <para>
              O arquivo não foi alterado no diretório local,
              mas foi alterado no repositório. O arquivo pode ser
              eventualmente atualizado, para sincronizá-lo com a
              última revisão pública. O comando
              <command>svn
              commit</command>
              no arquivo não irá fazer nada, mas
              o comando
              <command>svn update</command>
              irá trazer
              as últimas alterações para a sua cópia local.
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Localmente Modificado, e desatualizado</term>

          <listitem>
            <para>
              O arquivo foi alterado tanto no diretório loca quanto
              no repositório. O comando
              <command>svn commit</command>
              no arquivo irá falhar com o erro
              <quote>out-of-date</quote>
              (desatualizado). O arquivo deve ser atualizado primeiro; o
              comando
              <command>svn update</command>
              vai tentar fundir
              as alterações do repositório com as locais. Se o Subversion
              não conseguir completar a fusão de uma forma plausível
              automaticamente, ele deixará para o usuário resolver o
              conflito.
            </para>
          </listitem>
        </varlistentry>
      </variablelist>


      <para>
        Isto pode soar como muito para acompanhar, mas o comando
        <command>svn status</command>
        mostrará para você o estado de
        qualquer item em seu diretório local. Para maiores informações
        sobre este comando, veja
        <xref linkend="svn.tour.cycle.examine.status" />
        .
      </para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.in-action.mixedrevs">
      <title>Revisões Locais Mistas</title>

      <para>Como um princípio geral, o Subversion tenta ser tão flexível
        quanto possível. Um tipo especial de flexibilidade é a capacidade
        de ter uma cópia local contendo arquivos e diretórios com uma
        mistura de diferentes revisões. Infelizmente esta flexibilidade
        tende a confundir inúmeros novos usuários. Se o exemplo anterior
        mostrando revisões mistas deixou você perplexo, aqui está um
        exemplo mostrando tanto a razão pela qual o funcionalidade
        existe, quanto como fazer para usá-la.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.basic.in-action.mixedrevs.update-commit">
        <title>Atualizações e Submissões são Separados</title>

        <para>
          Uma das regras fundamentais do Subversion é
          que uma ação de
          <quote>push</quote>
          não causa um
          <quote>pull</quote>
          , e vice versa. Só porque você está
          pronto para publicar novas alterações no repositório não
          significa que você está pronto para receber as alterações
          de outras pessoas. E se você tiver novas alterações em curso,
          então o comando
          <command>svn update</command>
          deveria
          graciosamente fundir as alterações no repositório com as
          suas próprias, ao invés de forçar você a publicá-las.
        </para>

        <para>O principal efeito colateral dessa regra significa que
          uma cópia local tem que fazer uma escrituração extra para
          acompanhar revisões mistas, bem como ser tolerante a misturas.
          Isso fica mais complicado pelo fato de os diretórios também
          serem versionados.</para>

        <para>
          Por exemplo, suponha que você tenha uma cópia local
          inteiramente na revisão 10. Você edita o arquivo
          <filename>foo.html</filename>
          e então realiza um comando
          <command>svn commit</command>
          , o qual cria a revisão 15
          no repositório. Após o commit acontecer, muitos novos usuários
          poderiam esperar que a cópia local estivesse na revisão 15,
          mas este não é o caso! Qualquer número de alterações poderia
          ter acontecido no repositório entre as revisões 10 e 15.
          O cliente nada sabe sobre essas alterações no repositório,
          pois você ainda não executou o comando
          <command>svn update
          </command>
          , e o comando
          <command>svn commit</command>
          não
          baixou as novas alterações no repositório. Se por outro lado,
          o comando
          <command>svn commit</command>
          <emphasis>tivesse
          </emphasis>
          feito o download das novas alterações automaticamente,
          então seria possível que a cópia local inteira estivesse na revisão
          15 - mas então nós teríamos quebrado a regra fundamental onde
          <quote>push</quote>
          e
          <quote>pull</quote>
          permanecem como
          ações separadas. Portanto a única coisa segura que o cliente
          Subversion pode fazer é marcar o arquivo -
          <filename>foo.html
          </filename>
          com a revisão 15. O restante da cópia local permanece
          na revisão 10. Somente executando o comando
          <command>svn update
          </command>
          as alterações mais recentes no repositório serão
          baixadas, o a cópia local inteira será marcada com a revisão
          15.
        </para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.basic.in-action.mixedrevs.normal">
        <title>Revisões misturadas são normais</title>

        <para>
          O fato é,
          <emphasis>cada vez</emphasis>
          que você executar
          um comando
          <command>svn commit</command>
          , sua cópia local
          acabará tendo uma mistura de revisões. As coisas que você acabou
          de publicar são marcadas com um número de revisão maior que todo
          o resto. Após várias submissões (sem atualizações entre eles) sua cópia
          local irá conter uma completa mistura de revisões. Mesmo que você
          seja a única pessoa utilizando o repositório, você ainda verá este
          fenômeno. Para analisar a sua mistura de revisões use o comando
          <command>svn status --verbose</command>
          (veja
          <xref linkend="svn.tour.cycle.examine.status" />
          para maiores
          informações.)
        </para>

        <para>
          Freqüentemente, os novos usuários nem tomam consciência
          de que suas cópias locais contêm revisões mistas. Isso pode
          ser confuso, pois muitos comandos no cliente são sensíveis
          às revisões que eles estão examinando. Por exemplo, o comando
          <command>svn log</command>
          é usado para mostrar o histórico de
          alterações em um arquivo ou diretório (veja
          <xref linkend="svn.tour.history.log" />
          ). Quando o usuário invoca este
          comando em um objeto da cópia local, ele espera ver o histórico
          inteiro do objeto. Mas se a revisão local do objeto é muito
          velha (muitas vezes porque o comando
          <command>svn update</command>
          não foi executado por um longo tempo), então o histórico da
          versão
          <emphasis>antiga</emphasis>
          do objeto é que será
          mostrado.
        </para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.basic.in-action.mixedrevs.useful">
        <title>Revisões mistas são úteis</title>

        <para>
          Se o seu projeto for suficientemente complexo, você irá
          descobrir que algumas vezes é interessante forçar um
          <firstterm>
          backdate</firstterm>
          (ou, atualizar para uma revisão mais antiga
          que a que você tem) de partes de sua cópia local para revisões
          anteriores; você irá aprender como fazer isso em
          <xref linkend="svn.tour" />
          . Talvez você queira testar uma versão anterior
          de um submódulo contido em um subdiretório, ou talvez queira
          descobrir quando um bug apareceu pela primeira vez eu arquivo
          específico. Este é o aspecto de
          <quote>máquina do tempo</quote>
          de um sistema de controle de versão - a funcionalidade que te permite
          mover qualquer parte de sua cópia local para frente ou para trás
          na história.
        </para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.basic.in-action.mixedrevs.limits">
        <title>Revisões mistas têm limitações</title>

        <para>Apesar de você poder fazer uso de revisões mistas em seu
          ambiente local, esta flexibilidade tem limitações.</para>

        <para>Primeiramente, você não pode publicar a deleção de um arquivo
          ou diretório que não esteja completamente atualizado. Se uma
          versão mais nova do item existe no repositório, sua tentativa de
          deleção será rejeitada, para prevenir que você acidentalmente
          destrua alterações que você ainda não viu.</para>

        <para>
          Em segundo lugar, você não pode publicar alterações em metadados
          de diretórios a menos que ele esteja completamente atualizado.
          Você irá aprender a anexar
          <quote>propriedades</quote>
          aos itens
          em
          <xref linkend="svn.advanced" />
          . Uma revisão em um diretório local
          define um conjunto específico de entradas e propriedades, e assim,
          publicar alterações em propriedades de um diretório desatualizado
          pode destruir propriedades que você ainda não viu.
        </para>

      </sect3>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.basic.summary">
    <title>Sumário</title>

    <para>Nós abordamos uma série de conceitos fundamentais do
      Subversion neste capítulo:</para>

    <itemizedlist>
      <listitem>
        <para>Nós introduzimos as noções de repositório central,
          cópia local do cliente, e o array de árvores de revisões.</para>
      </listitem>

      <listitem>
        <para>
          Vimos alguns exemplos simples de como dois colaboradores
          podem utilizar o Subversion para publicar e receber as
          alterações um do outro, utilizando o modelo
          <quote>
          copy-modify-merge</quote>
          .
        </para>
      </listitem>

      <listitem>
        <para>Nós falamos um pouco sobre a maneira como o Subversion
          acompanha e gerencia as informações de uma cópia local
          do repositório.</para>
      </listitem>

    </itemizedlist>

    <para>Neste ponto, você deve ter uma boa idéia de como o Subversion
      funciona no sentido mais geral. Com este conhecimento, você já
      deve estar pronto para avançar para o próximo capítulo, que é um
      relato detalhado dos comandos e recursos do Subversion.</para>

  </sect1>

</chapter>
<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
